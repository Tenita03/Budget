<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Paycheck Tracker â€“ Stable Base (Recurring Bills + Debt Linking + Payoff Plan)</title>

<style>
:root{
  --bg:#f3f4f6;
  --card:#ffffff;
  --text:#0f172a;
  --muted:#64748b;
  --line:#e5e7eb;
  --brand:#007aff;
  --radius:16px;
  --shadow:0 10px 30px rgba(0,0,0,.06);
}

table input, table select {
  color: var(--text);
}

html, body {
  max-width: 100%;
  overflow-x: hidden;
}

.remove-btn{
  touch-action: manipulation;
}

.wrap, .card {
  max-width: 100%;
  overflow-x: hidden;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  background:var(--bg);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",system-ui,sans-serif;
  color:var(--text);
}
.wrap{ max-width:900px; margin:auto; padding:16px; }
.card{
  background:var(--card);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:16px;
  margin-bottom:16px;
}
h2{ margin:0 0 12px; font-size:18px; }
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}
.section-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  cursor:pointer;
}
.section-toggle{ font-size:13px; color:var(--muted); }
.collapsed table,
.collapsed button,
.collapsed #debt,
.collapsed .template-ui,
.collapsed .payoff-ui {
  display:none;
}

input, select, button{
  padding:10px;
  border-radius:10px;
  border:1px solid var(--line);
  font-size:15px;
}
button{
  background:var(--brand);
  color:#fff;
  border:none;
  cursor:pointer;
}
button.secondary{ background:#94a3b8; }

/* Tables: prevent horizontal scroll on narrow widths */
table{
  width:100%;
  border-collapse:collapse;
  table-layout:fixed;
}

.remove-btn{
  width: 34px;
  height: 34px;
  border-radius: 10px;
  border: 1px solid var(--line);
  background: #fff;
  color: #ef4444;
  font-size: 22px;
  line-height: 1;
  cursor: pointer;
}
.remove-btn:active{
  transform: scale(0.98);
}

th, td{
  padding:8px;
  border-bottom:1px solid var(--line);
  text-align:left;
  vertical-align:middle;
  overflow:hidden;
}
th{ font-size:12px; color:var(--muted); }
table input, table select{
  width:100%;
  background:#fafafa;
}
table tr:hover{ background:#f8fafc; }

td[data-label="Remove"]{
  overflow: visible;
}

td[data-label="Name"]{
  overflow: visible;
}
td[data-label="Name"] input{
  min-width: 140px;
}

td[data-label="Name"] input{
  min-width: 140px;
}

td[data-label="Remove"]{
  overflow: visible;
}
.remove{ cursor:pointer; color:#94a3b8; font-size:18px; user-select:none; }
.remove:hover{ color:#ef4444; }

.kpi{ display:flex; justify-content:space-between; align-items:center; }
.kpi .value{ font-size:28px; font-weight:800; }

.sticky-remaining{ position: sticky; top:0; z-index:10; }

#breakdownContent{
  display:grid;
  grid-template-columns:1fr auto;
  row-gap:6px;
}
.breakdown-line{ display:contents; }
.breakdown-line span:last-child{ font-weight:600; }
.breakdown-total{
  margin-top:6px;
  padding-top:6px;
  border-top:1px solid var(--line);
  font-weight:700;
}

/* Lock ONLY data entry â€” never navigation */
.locked #income input,
.locked #bills input,
.locked #bills select,
.locked #debt input,
.locked #debt select,
.locked .remove,
.locked .remove-btn,
.locked .debt-remove,
.locked #addIncome,
.locked #addBill,
.locked #addDebt,
.locked #addTemplate,
.locked .template-ui .remove {
  pointer-events:none;
  opacity:.6;
}

/* debug */
#debug{
  font-size:12px;
  color:var(--muted);
  margin-top:8px;
}
#debug strong{ color:var(--text); }

/* Debt cards */
.debt-card{
  border:1px solid var(--line);
  border-radius:14px;
  padding:14px;
  margin-bottom:12px;
  background:#fff;
  box-shadow:0 4px 12px rgba(0,0,0,.04);
}
.debt-title input{
  width:100%;
  font-weight:700;
  font-size:16px;
  margin-bottom:10px;
}
.debt-field{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:8px;
  gap:12px;
}
.debt-field label{ font-size:13px; color:var(--muted); }
.debt-field input{ max-width:160px; text-align:right; }
.debt-results{
  margin-top:10px;
  padding-top:10px;
  border-top:1px dashed var(--line);
  font-size:13px;
}
.debt-results div{
  display:flex;
  justify-content:space-between;
  margin-bottom:4px;
  font-weight:600;
}
.debt-badge{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  border:1px solid var(--line);
  background:#f8fafc;
  font-size:13px;
  display:flex;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
}
.debt-badge strong{ font-weight:800; }
.debt-remove{
  margin-top:10px;
  background:#e5e7eb;
  color:#334155;
}

/* Template UI */
.template-ui{
  border-top:1px solid var(--line);
  padding-top:12px;
  margin-top:12px;
}
.template-row{
  display:grid;
  grid-template-columns: 1.4fr 1fr .8fr .8fr auto;
  gap:10px;
  align-items:center;
}
.template-row input, .template-row select{ width:100%; }
.template-row .remove{ font-size:20px; padding:0 6px; }

/* Payoff UI */
.payoff-ui{
  border-top:1px solid var(--line);
  padding-top:12px;
  margin-top:12px;
}
.payoff-row{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap:10px;
  align-items:center;
}
.payoff-table{
  margin-top:10px;
  border:1px solid var(--line);
  border-radius:12px;
  overflow:hidden;
}
.payoff-table .hdr,
.payoff-table .r{
  display:grid;
  grid-template-columns: 1.4fr .8fr .8fr .9fr;
  gap:10px;
  padding:10px;
}
.payoff-table .hdr{
  background:#f8fafc;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
}
.payoff-table .r{
  border-top:1px solid var(--line);
  font-size:13px;
}
.payoff-pill{
  display:inline-block;
  padding:4px 8px;
  border-radius:999px;
  border:1px solid var(--line);
  background:#fff;
  font-size:12px;
  color:#334155;
  font-weight:700;
}

/* Mobile stacked table cards */
@media (max-width:480px){
  .row{ grid-template-columns:1fr; }
  .template-row{ grid-template-columns: 1fr 1fr; }
  .payoff-row{ grid-template-columns:1fr; }
}

@media (max-width: 430px){

  thead { display:none; }

  tbody tr{
    background:#fff;
    border:1px solid var(--line);
    border-radius:14px;
    padding:12px;
    margin-bottom:12px;
    box-shadow:0 4px 12px rgba(0,0,0,.04);
    display:block;
  }

  tbody td{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    padding:6px 0;
    border:none;
    min-width:0;
  }

  tbody td::before{
    content: attr(data-label);
    font-weight:700;
    font-size:13px;
    flex:0 0 42%;
    min-width:0;
  }

  tbody td input,
  tbody td select{
    flex:1 1 auto;
    min-width:0;
    max-width:58%;
  }

  /* Bill Name: stacked so it never disappears */
  td[data-label="Name"]{
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
  }
  td[data-label="Name"]::before{
    flex:none;
  }
  td[data-label="Name"] input{
    width:100% !important;
    max-width:100% !important;
  }

  /* Hide Recurring + Linked Debt on mobile */
  td[data-label="Recurring"],
  td[data-label="Linked Debt"]{
    display:none;
  }

  /* Remove button: keep visible and tappable */
  td[data-label="Remove"]{
    justify-content:flex-end;
  }
  td[data-label="Remove"]::before{
    content:"";
    flex:0 0 0;
  }

  table{
    width:100%;
    overflow-x:hidden;
  }
}

  
</style>
</head>

<body>
<div class="wrap" id="app">

  <!-- HEADER -->
  <div class="card">
    <div class="row">
      <select id="month"></select>
      <select id="year"></select>
    </div>

    <div class="row" style="margin-top:10px;">
      <input id="startingBalance" type="number" placeholder="Starting balance" inputmode="decimal" />
      <button id="lockBtn" class="secondary" type="button">ðŸ”“ Lock Month</button>
    </div>

    <div id="debug">Status: <strong>loadingâ€¦</strong></div>
  </div>

  <!-- REMAINING -->
  <div class="card sticky-remaining">
    <div class="kpi">
      <div>Remaining This Month</div>
      <div class="value" id="remaining">$0.00</div>
    </div>

    <div class="card" id="breakdown" style="font-size:14px;color:#475569;margin-top:12px;">
      <div id="breakdownContent"></div>
    </div>
  </div>

  <div class="card" id="summary" style="font-size:14px;color:#475569;"></div>

  <!-- INCOME -->
  <div class="card">
    <div class="section-header" onclick="toggleSection(this)">
      <h2>Income</h2>
      <span class="section-toggle">Hide</span>
    </div>

    <table>
      <thead>
        <tr><th style="width:28%;">Date</th><th>Source</th><th style="width:24%;">Amount</th><th style="width:36px;"></th></tr>
      </thead>
      <tbody id="income"></tbody>
    </table>
    <button id="addIncome" type="button">+ Add Income</button>
  </div>

  <!-- BILLS -->
  <div class="card">
    <div class="section-header" onclick="toggleSection(this)">
      <h2>Bills</h2>
      <span class="section-toggle">Hide</span>
    </div>
<div style="display:flex; gap:10px; align-items:center; margin:8px 0 12px;">
  <div style="font-size:13px; color:var(--muted); font-weight:600;">Bills count:</div>
  <select id="billCountMode" style="max-width:220px;">
    <option value="all">All bills</option>
    <option value="unpaid">Only unpaid</option>
    <option value="paid">Only paid</option>
  </select>
</div>
    <table>
   <thead>
  <tr>
    <th style="width:44px;">âœ”</th>
    <th style="width:22%;">Due</th>
    <th style="width:22%;">Paid</th>
    <th style="width:26%;">Name</th>
    <th style="width:14%;">Amount</th>
    <th style="width:90px;">Recurring</th>
    <th style="width:18%;">Linked Debt</th>
    <th style="width:44px;"></th>
  </tr>
</thead>
      <tbody id="bills"></tbody>
    </table>

    <button id="addBill" type="button">+ Add Bill</button>

    <!-- Template manager -->
    <div class="template-ui">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
        <div style="font-weight:700;">Recurring Bills</div>
        <button id="addTemplate" type="button" class="secondary">+ Add Recurring Bill</button>
      </div>
      <div id="templates" style="margin-top:10px; display:grid; gap:10px;"></div>
      <div style="font-size:12px; color:var(--muted); margin-top:10px;">
        Recurring bills automatically appear in each month (once). You can still edit the due date/amount in a specific month without changing the template.
      </div>
    </div>
  </div>

  <!-- DEBT -->
  <div class="card">
    <div class="section-header" onclick="toggleSection(this)">
      <h2>Loans & Balances</h2>
      <span class="section-toggle">Hide</span>
    </div>

    <!-- Payoff plan -->
    <div class="payoff-ui">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
        <div style="font-weight:800;">Payoff Projection</div>
        <span class="payoff-pill" id="payoffSummary">â€”</span>
      </div>

      <div class="payoff-row" style="margin-top:10px;">
        <select id="payoffStrategy">
          <option value="avalanche">Avalanche (highest APR first)</option>
          <option value="snowball">Snowball (smallest balance first)</option>
        </select>
        <input id="extraPool" type="number" inputmode="decimal" placeholder="Extra pool (optional)" />
        <button id="recalcPayoff" type="button" class="secondary">Recalculate</button>
      </div>

      <div class="payoff-table" id="payoffTable" aria-label="Payoff projection table"></div>

      <div style="font-size:12px; color:var(--muted); margin-top:10px;">
        This is an estimate using monthly interest and your Payment + Extra fields, plus the optional Extra Pool applied by your chosen strategy.
      </div>
    </div>

    <div id="debt" style="margin-top:12px;"></div>
    <button id="addDebt" type="button">+ Add Debt</button>
  </div>

</div>

<script>
/* ========= STABLE CORE + RECURRING BILLS + DEBT LINKING + PAYOFF ========= */
const $ = id => document.getElementById(id);
const money = n => `$${(Number(n) || 0).toFixed(2)}`;

const round2 = (n) => Math.round((Number(n) || 0) * 100) / 100;

const app      = $("app");
const debugEl  = $("debug");

const monthSel = $("month");
const yearSel  = $("year");
const startBal = $("startingBalance");

const incomeT  = $("income");
const billsT   = $("bills");
const debtT    = $("debt");

const remaining = $("remaining");
const lockBtn   = $("lockBtn");
const billCountMode = $("billCountMode");

const templatesEl = $("templates");
const addTemplateBtn = $("addTemplate");

const payoffStrategyEl = $("payoffStrategy");
const extraPoolEl = $("extraPool");
const recalcPayoffBtn = $("recalcPayoff");
const payoffTableEl = $("payoffTable");
const payoffSummaryEl = $("payoffSummary");

let locked = false;
let lastKey = null;

let computedDebtsThisMonth = [];
let computedDebtsStartOfMonth = [];

function setDebug(msg){
  debugEl.innerHTML = `Status: <strong>${msg}</strong>`;
}

function uid(prefix="id"){
  return `${prefix}_${Math.random().toString(36).slice(2,10)}_${Date.now().toString(36)}`;
}

/* ===== Templates (global) ===== */
function getBillTemplates(){
  return JSON.parse(localStorage.getItem("bill-templates") || "[]");
}
function saveBillTemplates(templates){
  localStorage.setItem("bill-templates", JSON.stringify(templates));
}

/* ===== Global debts store (carry-forward) =====
   debts-master holds the "current" balances across months.
   Each month still saves debt array snapshot only for UI fields,
   but on load we source from debts-master to carry forward.
*/
function getDebtsMaster(){
  return JSON.parse(localStorage.getItem("debts-master") || "[]");
}
function saveDebtsMaster(debts){
  localStorage.setItem("debts-master", JSON.stringify(debts));
}

/* Month / Year */
(function initMonthYear(){
  const now = new Date();
  for(let i=0;i<12;i++){
    monthSel.add(new Option(new Date(0,i).toLocaleString("default",{month:"long"}), i));
  }
  for(let y=2024;y<2036;y++){
    yearSel.add(new Option(y, y));
  }
  monthSel.value = now.getMonth();
  yearSel.value  = now.getFullYear();
})();

function key(){
  return `stable-${yearSel.value}-${monthSel.value}`;
}

function setDebtBaseline(debtId, newBalance){
  const baselines = getDebtBaselines();
  baselines[debtId] = Number(newBalance) || 0;
  saveDebtBaselines(baselines);

  // âœ… Cutoff: start applying payments AFTER the month you set the baseline
  const meta = getDebtBaselineMeta();
  const nm = nextMonth(yearSel.value, monthSel.value);
  meta[debtId] = { cutY: nm.y, cutM: nm.m };
  saveDebtBaselineMeta(meta);

  // Update master immediately so UI stays consistent
  const debts = getDebtsMaster().map(d =>
    String(d.id) === String(debtId)
      ? { ...d, balance: round2(newBalance) }
      : d
  );
  saveDebtsMaster(debts);
}

function getDebtBaselineMeta(){
  return JSON.parse(localStorage.getItem("debt-baseline-meta") || "{}");
}
function saveDebtBaselineMeta(meta){
  localStorage.setItem("debt-baseline-meta", JSON.stringify(meta));
}

// month increment helper
function nextMonth(y, m){
  m = Number(m);
  y = Number(y);
  if(m >= 11) return { y: y + 1, m: 0 };
  return { y, m: m + 1 };
}

function toggleSection(header){
  const card = header.closest(".card");
  const label = header.querySelector(".section-toggle");
  card.classList.toggle("collapsed");
  label.textContent = card.classList.contains("collapsed") ? "Show" : "Hide";
}

/* ===== Data getters ===== */
function getIncomeData(){
  return [...incomeT.querySelectorAll("tr")].map(r => ({
    id:     r.dataset.rowId || uid("inc"),
    date:   r.querySelector('td[data-label="Date"] input')?.value || "",
    source: r.querySelector('td[data-label="Source"] input')?.value || "",
    amount: r.querySelector('td[data-label="Amount"] input')?.value || ""
  }));
}

function getBillsData(){
  return [...billsT.querySelectorAll("tr")].map(r => ({
    id: r.dataset.rowId || uid("bill"),
    templateId: r.dataset.templateId || null,
    paid: r.querySelector('[data-label="Paid"] input')?.checked || false,
    dueDate: r.querySelector('[data-label="Due Date"] input')?.value || "",
    paidDate: r.querySelector('[data-label="Paid Date"] input')?.value || "",
    name: r.querySelector('[data-label="Name"] input')?.value || "",
    amount: r.querySelector('[data-label="Amount"] input')?.value || "",
    recurring: r.querySelector('[data-label="Recurring"] input')?.checked || false,
    linkedDebtId: r.querySelector('[data-label="Linked Debt"] select')?.value || ""
  }));
}

function getDebtUIData(){
  return [...debtT.querySelectorAll(".debt-card")].map(card=>{
    const i = card.querySelectorAll("input");
    return {
      id:      card.dataset.debtId,
      name:    i[0].value,
      balance: i[1].value,
      apr:     i[2].value,
      payment: i[3].value,
      extra:   i[4].value
    };
  });
}

function clear(el){ el.innerHTML = ""; }

/* ===== Row builder (for income + bills) ===== */
function addRow(tbody, cellsHtml, opts = {}){
  const tr = document.createElement("tr");
  tr.dataset.templateId = opts.templateId ? String(opts.templateId) : "";
  tr.dataset.rowId = opts.rowId || uid(tbody === billsT ? "bill" : "inc");
  tr.innerHTML = cellsHtml + `
  <td data-label="Remove">
    <button type="button" class="remove-btn" aria-label="Remove">Ã—</button>
  </td>
`;

  const removeBtn = tr.querySelector(".remove-btn");
if(removeBtn){
  removeBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    if(locked) return;
    tr.remove();
    update();
  });
}

  // Wire inputs/selects
  tr.querySelectorAll("input, select").forEach(el => {
    el.addEventListener("input", update);
    el.addEventListener("change", update);
  });

  // Bills: paid checkbox controls paid date
  const paid = tr.querySelector('td[data-label="Paid"] input');
  const paidDate = tr.querySelector('td[data-label="Paid Date"] input');

  if(paid && paidDate){
    const sync = () => {
      if(paid.checked){
        paidDate.disabled = false;
        if(!paidDate.value){
          paidDate.value = new Date().toISOString().slice(0,10);
        }
      } else {
        paidDate.value = "";
        paidDate.disabled = true;
      }
    };
    sync();
    paid.addEventListener("change", () => { sync(); update(); });
  }

  // Linked debt dropdown
  const debtSelect = tr.querySelector('td[data-label="Linked Debt"] select');
  if(debtSelect){
    populateDebtSelect(debtSelect, opts.selectedDebtId || "");
  }

  tbody.appendChild(tr);
  return tr;
}

function populateDebtSelect(select, selectedId = ""){
  if(!select) return;
  const debts = getDebtsMaster();
  select.innerHTML = `<option value="">â€” None â€”</option>`;
  debts.forEach(d => {
    const opt = document.createElement("option");
    opt.value = d.id;
    opt.textContent = d.name || "Unnamed Debt";
    if(String(d.id) === String(selectedId)) opt.selected = true;
    select.appendChild(opt);
  });
}

function refreshAllBillDebtDropdowns(){
  billsT.querySelectorAll('td[data-label="Linked Debt"] select').forEach(sel => {
    const current = sel.value || "";
    populateDebtSelect(sel, current);
  });
}

function refreshAllDebtSelects(){
  const debts = getDebtsMaster();

  billsT.querySelectorAll('td[data-label="Linked Debt"] select').forEach(sel=>{
    const current = sel.value || "";
    sel.innerHTML = `<option value="">â€” None â€”</option>`;
    debts.forEach(d=>{
      const opt = document.createElement("option");
      opt.value = d.id;
      opt.textContent = d.name || "Unnamed Debt";
      if(String(d.id) === String(current)) opt.selected = true;
      sel.appendChild(opt);
    });
  });
}

/* ===== Recurring template upsert from bill row ===== */
function upsertBillTemplateFromRow(row){
  const recurring = row.querySelector('[data-label="Recurring"] input');
  if(!recurring || !recurring.checked) return;

  const name   = row.querySelector('[data-label="Name"] input')?.value || "";
  const amount = row.querySelector('[data-label="Amount"] input')?.value || "";
  const due    = row.querySelector('[data-label="Due Date"] input')?.value || "";
  if(!name || !amount || !due) return;

  const dueDay = new Date(due).getDate();
  let templates = getBillTemplates();
  let existing = templates.find(t => t.name === name);

  if(!existing){
    templates.push({ id: uid("t"), name, amount, dueDay, recurring: true });
    saveBillTemplates(templates);
    renderTemplatesUI();
  }
}

/* ===== Debt Cards ===== */
function createDebtCard(data = {}){
  const card = document.createElement("div");
  card.className = "debt-card";
  card.dataset.debtId = data.id || uid("debt");

  card.innerHTML = `
    <div class="debt-title">
      <input placeholder="Debt name" value="${data.name || ""}">
    </div>

    <div class="debt-field">
      <label>Balance</label>
      <input class="balance-input" type="number" inputmode="decimal" value="${data.balance ?? ""}">
    </div>

    <div class="debt-field">
      <label>APR %</label>
      <input type="number" inputmode="decimal" value="${data.apr ?? ""}">
    </div>

    <div class="debt-field">
      <label>Payment</label>
      <input type="number" inputmode="decimal" value="${data.payment ?? ""}">
    </div>

    <div class="debt-field">
      <label>Extra</label>
      <input type="number" inputmode="decimal" value="${data.extra ?? ""}">
    </div>

    <div class="debt-results">
      <div><span>Interest (this monthâ€™s linked payments)</span><span class="interest">$0.00</span></div>
      <div><span>Principal (this monthâ€™s linked payments)</span><span class="principal">$0.00</span></div>
      <div><span>New Balance (after linked payments)</span><span class="newbal">$0.00</span></div>
    </div>

    <div class="debt-badge" aria-label="Debt badges">
      <div>Paid this month: <strong class="paidThisMonth">$0.00</strong></div>
      <div>Linked bills paid: <strong class="countThisMonth">0</strong></div>
      <div>Last paid: <strong class="lastPaid">â€”</strong></div>
    </div>

    <button class="debt-remove" type="button">Remove Debt</button>
  `;

  const inputs = card.querySelectorAll("input");
  const nameInput = inputs[0];
  const balInput  = inputs[1]; // .balance-input
  const aprInput  = inputs[2];
  const payInput  = inputs[3];
  const extraInput= inputs[4];

  // âœ… Balance should update baseline immediately so recompute won't "erase" it
  const handleBalanceChange = () => {
    if(locked) return;
    setDebtBaseline(card.dataset.debtId, balInput.value);
    // recompute + refresh UI
    update();
  };

  // On mobile Safari, "change" can be finicky; input keeps it stable.
  balInput.addEventListener("input", handleBalanceChange);
  balInput.addEventListener("change", handleBalanceChange);
  balInput.addEventListener("blur", handleBalanceChange);

  // Other fields just sync master + update
  [nameInput, aprInput, payInput, extraInput].forEach(el => {
    el.addEventListener("input", () => {
      if(locked) return;
      syncDebtMasterFromUI();  // keeps names/APR/payment current
      update();
    });
    el.addEventListener("change", () => {
      if(locked) return;
      syncDebtMasterFromUI();
      update();
    });
  });

  card.querySelector(".debt-remove").addEventListener("click", () => {
    if(locked) return;

    const id = card.dataset.debtId;

    // remove from master
    const debts = getDebtsMaster().filter(d => String(d.id) !== String(id));
    saveDebtsMaster(debts);

    // remove baseline too
    const baselines = getDebtBaselines();
    delete baselines[id];
    saveDebtBaselines(baselines);

    // unlink bills that pointed to it (UI now; persists on save())
    billsT.querySelectorAll('tr').forEach(tr=>{
      const sel = tr.querySelector('td[data-label="Linked Debt"] select');
      if(sel && String(sel.value) === String(id)) sel.value = "";
    });

    card.remove();
    refreshAllDebtSelects();
    update();
  });

    debtT.appendChild(card);
  refreshAllBillDebtDropdowns();
}

function syncDebtMasterFromUI(){
  const ui = getDebtUIData();
  const master = getDebtsMaster();

  const merged = ui.map(d => {
    const existing = master.find(m => String(m.id) === String(d.id)) || {};
    return {
      id: d.id,
      name: d.name || "",
      // âœ… DON'T overwrite balance hereâ€”baseline+recompute owns it
      balance: Number(existing.balance) || 0,
      apr: Number(d.apr) || 0,
      payment: Number(d.payment) || 0,
      extra: Number(d.extra) || 0
    };
  });

  saveDebtsMaster(merged);
  refreshAllBillDebtDropdowns();
}

/* ===== Loaders ===== */
function loadIncomeRows(data=[]){
  data.forEach(row => {
    const tr = addRow(incomeT, `
      <td data-label="Date"><input type="date" value="${row.date || ""}"></td>
      <td data-label="Source"><input value="${row.source || ""}"></td>
      <td data-label="Amount"><input type="number" inputmode="decimal" value="${row.amount || ""}"></td>
    `, { rowId: row.id || uid("inc") });
    tr.dataset.rowId = row.id || tr.dataset.rowId;
  });
}

function loadBillRows(data = []){
  // 1) Load saved bills
  data.forEach(row => {
    const tr = addRow(billsT, `
      <td data-label="Paid"><input type="checkbox" ${row.paid ? "checked" : ""}></td>
      <td data-label="Due Date"><input type="date" value="${row.dueDate || ""}"></td>
      <td data-label="Paid Date"><input type="date" value="${row.paidDate || ""}"></td>
      <td data-label="Name"><input value="${row.name || ""}"></td>
      <td data-label="Amount"><input type="number" inputmode="decimal" value="${row.amount || ""}"></td>
      <td data-label="Recurring"><input type="checkbox" ${row.recurring ? "checked" : ""}></td>
      <td data-label="Linked Debt"><select></select></td>
    `, {
      templateId: row.templateId || null,
      rowId: row.id || uid("bill"),
      selectedDebtId: row.linkedDebtId || ""
    });
    tr.dataset.rowId = row.id || tr.dataset.rowId;
  });

  // 2) Inject recurring templates (once per month)
  const templates = getBillTemplates();
  const existingNames = new Set(
    [...billsT.children].map(r =>
      r.querySelector('[data-label="Name"] input')?.value
    )
  );

  templates.forEach(t => {
    if(!t.recurring) return;
    if(existingNames.has(t.name)) return;

    const due = new Date(yearSel.value, monthSel.value, t.dueDay).toISOString().slice(0,10);

    addRow(billsT, `
      <td data-label="Paid"><input type="checkbox"></td>
      <td data-label="Due Date"><input type="date" value="${due}"></td>
      <td data-label="Paid Date"><input type="date" disabled></td>
      <td data-label="Name"><input value="${t.name}"></td>
      <td data-label="Amount"><input type="number" inputmode="decimal" value="${t.amount}"></td>
      <td data-label="Recurring"><input type="checkbox" checked></td>
      <td data-label="Linked Debt"><select></select></td>
    `, { templateId: t.id, rowId: uid("bill"), selectedDebtId: "" });
  });
}

function loadDebtFromMasterOrMonth(monthDebtSnapshot=[]){
  // Master carries forward; if empty and month has snapshot, seed master from it.
  let master = getDebtsMaster();
  if(master.length === 0 && (monthDebtSnapshot || []).length){
    master = monthDebtSnapshot.map(d=>({
      id: d.id || uid("debt"),
      name: d.name || "",
      balance: Number(d.balance) || 0,
      apr: Number(d.apr) || 0,
      payment: Number(d.payment) || 0,
      extra: Number(d.extra) || 0
    }));
    saveDebtsMaster(master);
  }

  // Render from master
  clear(debtT);
  getDebtsMaster().forEach(d => createDebtCard(d));
  refreshAllDebtSelects();
}

/* ===== Calculations ===== */
function sumIncome(){
  let total = 0;
  incomeT.querySelectorAll("tr").forEach(r=>{
    const amt = Number(r.querySelector('td[data-label="Amount"] input')?.value) || 0;
    total += amt;
  });
  return total;
}

function sumBills(){
  let total = 0;
  const mode = billCountMode ? billCountMode.value : "all";

  billsT.querySelectorAll("tr").forEach(r=>{
    const amt  = Number(r.querySelector('td[data-label="Amount"] input')?.value) || 0;
    const paid = r.querySelector('td[data-label="Paid"] input')?.checked || false;

    // visual only
    r.style.opacity = paid ? 0.45 : 1;

    // counting logic
    if (mode === "unpaid" && paid) return;
    if (mode === "paid" && !paid) return;

    total += amt;
  });

  return total;
}

/* ===== Debt update from linked paid bills (this month, visible feedback) =====
   IMPORTANT:
   - Remaining is NOT affected by debt.
   - Debt balances are updated globally (debts-master) based on paid linked bills.
   - We avoid double-application by recomputing from a stored "baseline" per debt + all paid linked payments history.
*/
function allMonthKeys(){
  const keys = [];
  for(let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    if(/^stable-\d{4}-\d{1,2}$/.test(k)) keys.push(k);
  }
  return keys.sort();
}

function collectAllPaidLinkedPayments(){
  // returns array of {debtId, amount, y, m, dateISO, billId}
  const out = [];
  const keys = allMonthKeys();
  const meta = getDebtBaselineMeta();

  keys.forEach(k=>{
    // k is like "stable-2026-0"
    const parts = k.split("-");
    const y = Number(parts[1]);
    const m = Number(parts[2]);

    const d = JSON.parse(localStorage.getItem(k) || "{}");
    const bills = d.bills || [];

    bills.forEach(b=>{
      if(!b || !b.paid || !b.linkedDebtId) return;

      // âœ… apply cutoff per-debt
      const cut = meta[b.linkedDebtId];
      if(cut){
        if(y < cut.cutY) return;
        if(y === cut.cutY && m < cut.cutM) return;
      }

      const amt = Number(b.amount) || 0;
      if(amt <= 0) return;

      const date = b.paidDate || b.dueDate || "";
      out.push({
        debtId: b.linkedDebtId,
        amount: amt,
        y, m,
        dateISO: date || "9999-12-31",
        billId: b.id || uid("bill")
      });
    });
  });

  // stable-ish ordering
  out.sort((a,b)=> (a.y - b.y) || (a.m - b.m) || String(a.dateISO).localeCompare(String(b.dateISO)));
  return out;
}

// Store baseline starting balances to make recompute deterministic
function getDebtBaselines(){
  return JSON.parse(localStorage.getItem("debt-baselines") || "{}");
}
function saveDebtBaselines(b){
  localStorage.setItem("debt-baselines", JSON.stringify(b));
}

function ensureBaselines(){
  const baselines = getDebtBaselines();
  const debts = getDebtsMaster();
  let changed = false;
  debts.forEach(d=>{
    if(baselines[d.id] == null){
      baselines[d.id] = Number(d.balance) || 0;
      changed = true;
    }
  });
  // Remove baselines for deleted debts
  Object.keys(baselines).forEach(id=>{
    if(!debts.some(d=>String(d.id)===String(id))){
      delete baselines[id];
      changed = true;
    }
  });
  if(changed) saveDebtBaselines(baselines);
  return baselines;
}

function computeDebtsUpToMonth(limitY, limitM, inclusive){
  const baselines = ensureBaselines();

  // Start from baselines
  const debts = getDebtsMaster().map(d=>({
    ...d,
    balance: round2(baselines[d.id] ?? 0)
  }));

  const payments = collectAllPaidLinkedPayments();

  payments.forEach(p=>{
    const beforeLimit =
      (p.y < limitY) ||
      (p.y === limitY && p.m < limitM) ||
      (inclusive && p.y === limitY && p.m === limitM);

    if(!beforeLimit) return;

    const d = debts.find(x => String(x.id) === String(p.debtId));
    if(!d) return;

    const bal = Number(d.balance) || 0;
    const apr = Number(d.apr) || 0;

    const interest  = bal * (apr / 100 / 12);
    const principal = Math.max(p.amount - interest, 0);

    d.balance = round2(Math.max(bal - principal, 0));
  });

  return debts;
}

function function recomputeDebtsFromBaselinesAndPayments(){
  const y = Number(yearSel.value);
  const m = Number(monthSel.value);

  // Start-of-month = after prior months
  computedDebtsStartOfMonth = computeDebtsUpToMonth(y, m, false);

  // End-of-month = after this month too
  computedDebtsThisMonth = computeDebtsUpToMonth(y, m, true);

  // âœ… IMPORTANT: do NOT write computed balances back into the Balance input.
  // That input is the "baseline" the user typed.
  // We only use computedDebtsThisMonth for New Balance + payoff.

  refreshAllDebtSelects();
}

function monthPaidLinkedStats(){
  const month = JSON.parse(localStorage.getItem(key()) || "{}");
  const bills = month.bills || [];

  const stats = {}; // debtId -> {amt,count,lastDate,interest,principal}

  bills.forEach(b=>{
    if(!b || !b.paid || !b.linkedDebtId) return;
    const amt = Number(b.amount) || 0;
    if(amt <= 0) return;

    const id = b.linkedDebtId;
    stats[id] = stats[id] || {amt:0,count:0,lastDate:"â€”",interest:0,principal:0};
    stats[id].amt += amt;
    stats[id].count += 1;

    const dt = b.paidDate || b.dueDate || "";
    if(dt && (stats[id].lastDate==="â€”" || String(dt) > String(stats[id].lastDate))){
      stats[id].lastDate = dt;
    }
  });

  // Use start-of-month balance for interest math
  Object.keys(stats).forEach(debtId=>{
    const start = computedDebtsStartOfMonth.find(x=>String(x.id)===String(debtId));
    const bal = Number(start?.balance) || 0;
    const apr = Number(start?.apr) || 0;

    const interest  = bal * (apr/100/12);
    const principal = Math.max(stats[debtId].amt - interest, 0);

    stats[debtId].interest  = interest;
    stats[debtId].principal = principal;
  });

  return stats;
}

function renderDebtBadgesAndResults(){
  const stats = monthPaidLinkedStats();
  const debts = computedDebtsThisMonth.length ? computedDebtsThisMonth : getDebtsMaster();

  debtT.querySelectorAll(".debt-card").forEach(card=>{
    const id = card.dataset.debtId;
    const d = debts.find(x=>String(x.id)===String(id));
    const s = stats[id];

    const interestEl = card.querySelector(".interest");
    const principalEl = card.querySelector(".principal");
    const newBalEl = card.querySelector(".newbal");

    if(d){
      newBalEl.textContent = money(d.balance);
    }
    if(s){
      interestEl.textContent = money(s.interest);
      principalEl.textContent = money(s.principal);
      card.querySelector(".paidThisMonth").textContent = money(s.amt);
      card.querySelector(".countThisMonth").textContent = String(s.count);
      card.querySelector(".lastPaid").textContent = s.lastDate || "â€”";
    } else {
      interestEl.textContent = money(0);
      principalEl.textContent = money(0);
      card.querySelector(".paidThisMonth").textContent = money(0);
      card.querySelector(".countThisMonth").textContent = "0";
      card.querySelector(".lastPaid").textContent = "â€”";
    }
  });
}

/* ===== Payoff Projection ===== */
function simulatePayoff(strategy, extraPool){
  const base = computedDebtsThisMonth.length ? computedDebtsThisMonth : getDebtsMaster();
const debts = base.map(d=>({
    id: d.id,
    name: d.name || "Unnamed Debt",
    apr: Number(d.apr)||0,
    balance: Number(d.balance)||0,
    payment: Number(d.payment)||0,
    extra: Number(d.extra)||0
  })).filter(d=>d.balance>0);

  if(debts.length === 0){
    return { months:0, totalInterest:0, order:[], rows:[] };
  }

  // Order function
  const orderFn = (a,b)=>{
    if(strategy==="snowball"){
      return a.balance - b.balance || b.apr - a.apr;
    }
    // avalanche
    return b.apr - a.apr || a.balance - b.balance;
  };

  let months = 0;
  let totalInterest = 0;

  // copy balances
  const working = debts.map(d=>({...d}));

  // Safety cap
  const MAX_MONTHS = 600;

  while(working.some(d=>d.balance>0) && months < MAX_MONTHS){
    months += 1;

    // accrue interest
    working.forEach(d=>{
      if(d.balance<=0) return;
      const interest = d.balance*(d.apr/100/12);
      totalInterest += interest;
      d.balance += interest;
    });

    // pay minimums first
    working.forEach(d=>{
      if(d.balance<=0) return;
      const pay = Math.max(d.payment,0) + Math.max(d.extra,0);
      if(pay<=0) return;
      d.balance = Math.max(d.balance - pay, 0);
    });

    // extra pool by strategy
let pool = Math.max(Number(extraPool)||0, 0);

while(pool > 0.0001){
  const targets = working.filter(d=>d.balance>0).sort(orderFn);
  if(targets.length === 0) break;

  const t = targets[0];

  const chunk = Math.min(pool, t.balance);
  t.balance = Math.max(t.balance - chunk, 0);
  pool -= chunk;
}
  }

  const order = debts.sort(orderFn).map(d=>d.name);
  return { months, totalInterest, order };
}

function renderPayoff(){
  const strategy = payoffStrategyEl.value;
  const extraPool = Number(extraPoolEl.value)||0;

  const base = computedDebtsThisMonth.length ? computedDebtsThisMonth : getDebtsMaster();
const debts = base.map(d=>({
    name: d.name || "Unnamed Debt",
    balance: Number(d.balance)||0,
    apr: Number(d.apr)||0,
    payment: (Number(d.payment)||0) + (Number(d.extra)||0)
  })).filter(d=>d.balance>0);

  if(debts.length===0){
    payoffSummaryEl.textContent = "No active debts";
    payoffTableEl.innerHTML = `<div class="hdr"><div>Debt</div><div>APR</div><div>Balance</div><div>Payment</div></div>`;
    return;
  }

  const sim = simulatePayoff(strategy, extraPool);
  const yrs = Math.floor(sim.months/12);
  const mos = sim.months%12;
  payoffSummaryEl.textContent = `Debt-free in ${yrs ? yrs+"y " : ""}${mos}m â€¢ Est. interest ${money(sim.totalInterest)}`;

  // Sort for display
  const rows = debts.sort((a,b)=>{
    if(strategy==="snowball"){
      return a.balance - b.balance || b.apr - a.apr;
    }
    return b.apr - a.apr || a.balance - b.balance;
  });

  payoffTableEl.innerHTML = `
    <div class="hdr">
      <div>Debt (strategy order)</div><div>APR</div><div>Balance</div><div>Payment</div>
    </div>
    ${rows.map(r=>`
      <div class="r">
        <div>${r.name}</div>
        <div>${(r.apr||0).toFixed(2)}%</div>
        <div>${money(r.balance)}</div>
        <div>${money(r.payment)}</div>
      </div>
    `).join("")}
  `;
}

/* ===== Breakdown ===== */
function renderBreakdown(start, income, bills, remainingValue){
  $("breakdownContent").innerHTML = `
    <div class="breakdown-line"><span>Starting Balance</span><span>${money(start)}</span></div>
    <div class="breakdown-line"><span>Income</span><span style="color:#16a34a">+${money(income)}</span></div>
    <div class="breakdown-line"><span>Bills</span><span style="color:#dc2626">âˆ’${money(bills)}</span></div>
    <div class="breakdown-line breakdown-total"><span>Remaining</span><span>${money(remainingValue)}</span></div>
  `;
}

/* ===== Update ===== */
function update(){
  // First: keep master debts aligned with UI edits
  syncDebtMasterFromUI();

  const start  = Number(startBal.value) || 0;
  const income = sumIncome();
  const bills  = sumBills();

  // Remaining is cashflow only (debt is informational)
  const remainingValue = start + income - bills;
  remaining.textContent = money(remainingValue);

  // Upsert recurring templates from rows that are marked recurring
  billsT.querySelectorAll("tr").forEach(upsertBillTemplateFromRow);

  // Recompute global debts from baseline + ALL paid linked bills (prevents double-apply, supports revisiting months)
  recomputeDebtsFromBaselinesAndPayments();

  // Update debt badges and last payment impact
  renderDebtBadgesAndResults();

  // Payoff projection
  renderPayoff();

  renderBreakdown(start, income, bills, remainingValue);
  $("summary").textContent = "Monthly activity updated.";

  save();
}

/* ===== Save / Load ===== */
function save(){
  if(!lastKey) lastKey = key();

  localStorage.setItem(lastKey, JSON.stringify({
    locked,
    start: startBal.value || "",
    income: getIncomeData(),
    bills: getBillsData(),
    // store debt UI snapshot (not the source of truth, master is)
    debt: getDebtUIData(),
    payoff: {
      strategy: payoffStrategyEl.value,
      extraPool: extraPoolEl.value || ""
    }
  }));
}

function load(){
  lastKey = key();
  const d = JSON.parse(localStorage.getItem(lastKey) || "{}");

  locked = !!d.locked;
  app.classList.toggle("locked", locked);
  lockBtn.textContent = locked ? "ðŸ”’ Month Locked" : "ðŸ”“ Lock Month";

  startBal.value = d.start || "";

  // payoff prefs
  if(d.payoff?.strategy) payoffStrategyEl.value = d.payoff.strategy;
  extraPoolEl.value = d.payoff?.extraPool || "";

  clear(incomeT);
  clear(billsT);

  // income first
  loadIncomeRows(d.income || []);

  // âœ… load debts BEFORE bills so bill dropdowns can populate
  loadDebtFromMasterOrMonth(d.debt || []);

  // now bills
  loadBillRows(d.bills || []);

  // templates UI
  renderTemplatesUI();

  // ensure selects match latest debts
  refreshAllBillDebtDropdowns();

  update();
  setDebug(`Loaded ${yearSel.value}-${Number(monthSel.value) + 1} âœ…`);
}

/* ===== Templates UI ===== */
function renderTemplatesUI(){
  const templates = getBillTemplates();
  templatesEl.innerHTML = "";

  if(templates.length === 0){
    templatesEl.innerHTML = `<div style="color:var(--muted); font-size:13px;">No recurring bills yet.</div>`;
    return;
  }

  templates.forEach(t => {
    const row = document.createElement("div");
    row.className = "template-row";
    row.innerHTML = `
      <input data-k="name" placeholder="Name (e.g., Rent)" value="${t.name || ""}">
      <input data-k="amount" type="number" inputmode="decimal" placeholder="Amount" value="${t.amount ?? ""}">
      <input data-k="dueDay" type="number" min="1" max="31" placeholder="Due day" value="${t.dueDay ?? ""}">
      <select data-k="recurring">
        <option value="true" ${t.recurring ? "selected" : ""}>Recurring</option>
        <option value="false" ${!t.recurring ? "selected" : ""}>Off</option>
      </select>
      <span class="remove" title="Remove">Ã—</span>
    `;

    row.querySelectorAll("input, select").forEach(el => {
      el.addEventListener("input", () => {
        const updated = getBillTemplates().map(x => {
          if(String(x.id) !== String(t.id)) return x;
          const name = row.querySelector('[data-k="name"]').value;
          const amount = row.querySelector('[data-k="amount"]').value;
          const dueDay = row.querySelector('[data-k="dueDay"]').value;
          const recurring = row.querySelector('[data-k="recurring"]').value === "true";
          return { ...x, name, amount, dueDay, recurring };
        });
        saveBillTemplates(updated);
      });
    });

    row.querySelector(".remove").addEventListener("click", () => {
      const updated = getBillTemplates().filter(x => String(x.id) !== String(t.id));
      saveBillTemplates(updated);
      renderTemplatesUI();
    });

    templatesEl.appendChild(row);
  });
}

/* ===== Events ===== */
startBal.addEventListener("input", update);
startBal.addEventListener("change", update);

$("addIncome").addEventListener("click", () => {
  setDebug("Add Income clicked âœ…");
  if(locked) return;
  addRow(incomeT, `
    <td data-label="Date"><input type="date"></td>
    <td data-label="Source"><input></td>
    <td data-label="Amount"><input type="number" inputmode="decimal"></td>
  `);
  update();
});

$("addBill").addEventListener("click", () => {
  setDebug("Add Bill clicked âœ…");
  if(locked) return;
  addRow(billsT, `
    <td data-label="Paid"><input type="checkbox"></td>
    <td data-label="Due Date"><input type="date"></td>
    <td data-label="Paid Date"><input type="date" disabled></td>
    <td data-label="Name"><input></td>
    <td data-label="Amount"><input type="number" inputmode="decimal"></td>
    <td data-label="Recurring"><input type="checkbox"></td>
    <td data-label="Linked Debt"><select></select></td>
  `);
  refreshAllDebtSelects();
  update();
});

billCountMode.addEventListener("change", update);
$("addDebt").addEventListener("click", () => {
  setDebug("Add Debt clicked âœ…");
  if(locked) return;

  // Add to master first
  const debts = getDebtsMaster();
  const d = { id: uid("debt"), name:"", balance:0, apr:0, payment:0, extra:0 };
  debts.push(d);
  saveDebtsMaster(debts);

  // ensure baseline exists
  ensureBaselines();

  // Render card
  createDebtCard(d);
  refreshAllDebtSelects();
  update();
});

addTemplateBtn.addEventListener("click", () => {
  if(locked) return;
  const templates = getBillTemplates();
  templates.push({ id: uid("t"), name: "", amount: "", dueDay: 1, recurring: true });
  saveBillTemplates(templates);
  renderTemplatesUI();
});

lockBtn.addEventListener("click", () => {
  locked = !locked;
  app.classList.toggle("locked", locked);
  lockBtn.textContent = locked ? "ðŸ”’ Month Locked" : "ðŸ”“ Lock Month";
  save();
  setDebug(locked ? "Month locked âœ…" : "Month unlocked âœ…");
});

recalcPayoffBtn.addEventListener("click", renderPayoff);
payoffStrategyEl.addEventListener("change", update);
extraPoolEl.addEventListener("input", () => { renderPayoff(); save(); });

function handleMonthChange(){
  save();
  load();
}

monthSel.addEventListener("change", handleMonthChange);
yearSel.addEventListener("change", handleMonthChange);

/* Boot */
load();

// Robust remove handler (works for all bill rows, even after re-renders)
billsT.addEventListener("click", (e) => {
  const btn = e.target.closest(".remove-btn");
  if(!btn) return;
  e.preventDefault();
  e.stopPropagation();
  if(locked) return;
  const tr = btn.closest("tr");
  if(tr){
    tr.remove();
    update();
  }
});
</script>
</body>
</html>